package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class motorlibc_template
{
  protected static String nl;
  public static synchronized motorlibc_template create(String lineSeparator)
  {
    nl = lineSeparator;
    motorlibc_template result = new motorlibc_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[MOTORLIB.c]*/" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without**" + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series /XMC1000 Series                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : 27 Sept, 2013                                          **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** PA           Dave App Developer                                            **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @file  MOTORLIB.c" + NL + " *" + NL + " * @brief This file contains implementations of all Public and Private functions" + NL + " *        of Motor control library." + NL + " *" + NL + " */" + NL + " /* Revision History" + NL + " * 03 Apr 2013   v1.0.0    Initial version" + NL + " * 25 Apr 2013   v1.0.2    Added support for XMC1302" + NL + " * 29  May 2013  v1.0.12   Added FOC support for XMC1302" + NL + " * 21 June 2013  v1.0.14   Added support for XMC4400 and XMC4200 device" + NL + " * 24 Jul 2013   v1.0.18   Added FOC support for XMC4400 device" + NL + " * 27 Sept 2013  v1.0.21   Added FOC support for XMC45 & XMC42 device" + NL + " */ ";
  protected final String TEXT_2 = " " + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <DAVE3.h>" + NL + "#include \"../../inc/LIBS/MOTORLIB.h\"" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/**" + NL + "  * @ingroup MOTORLIBS_privatefunc" + NL + "  * @{" + NL + "  */" + NL + "#ifdef USE_MOTORLIBS  " + NL + "/*****************************************************************************" + NL + "**                      Private Type Definitions                            **" + NL + "******************************************************************************/";
  protected final String TEXT_3 = NL + "MATH_Type* const MotorMath= MATH;";
  protected final String TEXT_4 = NL + "/*****************************************************************************" + NL + " *                 Private Function declarations                             *" + NL + " *****************************************************************************/" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Imported Global Variables                             **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/";
  protected final String TEXT_5 = NL + "const int32_t e[23] = {0x20000000, 0x12E4051D, 0x9FB385B, 0x51111D4, 0x28B0D43, 0x145D7E1, 0xA2F61E, 0x517C55, 0x28BE53, 0x145F2E, 0xA2F98, 0x517CC, 0x28BE6, 0x145F3, 0xA2F9, 0x517C, 0x28BE, 0x145F, 0xA2F, 0x517, 0x28B, 0x145, 0xA2};";
  protected final String TEXT_6 = NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL;
  protected final String TEXT_7 = NL + "/**" + NL + " * This function is the implementation of cartesian to Polar Transformation." + NL + " */" + NL + "uint32_t MOTORLIBS_Car2Pol(int32_t x,int32_t y, int16_t *Angle)" + NL + "{" + NL + "  int32_t TempAngle;" + NL + "" + NL + "  /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->STATC =(uint32_t) MOTORLIBS_CLEAR_KEEPX + \\" + NL + "                    (uint32_t) MOTORLIBS_CLEAR_KEEPY + \\" + NL + "                (uint32_t) MOTORLIBS_CLEAR_KEEPZ;" + NL + "" + NL + "  MotorMath->CON = (uint32_t) MOTORLIBS_CIRCULAR_MODE + \\" + NL + "                   (uint32_t) MOTORLIBS_VECTORING_MODE + \\" + NL + "                   (uint32_t) MOTORLIBS_CORDIC_AUTO_START + \\" + NL + "                   (uint32_t) MOTORLIBS_UNSIGNED_X_RESULT + \\" + NL + "                   (uint32_t) MOTORLIBS_MPS_DIVBY1;" + NL + "" + NL + "  /*Loading CORDX,CORDY and CORDZ Registers*/" + NL + "  WR_REG(MotorMath->CORDZ, MATH_CORDZ_DATA_Msk, \\" + NL + "               MATH_CORDZ_DATA_Pos, (uint32_t)0);" + NL + "" + NL + "  WR_REG(MotorMath->CORDY, MATH_CORDY_DATA_Msk, \\" + NL + "               MATH_CORDY_DATA_Pos, y);" + NL + "" + NL + "  WR_REG(MotorMath->CORDX, MATH_CORDX_DATA_Msk, \\" + NL + "               MATH_CORDX_DATA_Pos, x);" + NL + "  /*Checking for CORIDC Busy Bit*/" + NL + "  while((MotorMath->STATC &0x1)==1);" + NL + "  /* Update the Amplitude and Angle Values*/" + NL + "  TempAngle = MotorMath->CORRZ;" + NL + "  *Angle  = (int16_t)(TempAngle >>((int32_t)MOTORLIBS_ANGLESCALE+MATH_CORDZ_DATA_Pos));" + NL + "  return (MotorMath->CORRX>>(uint32_t)MOTORLIBS_AMPSCALE);" + NL + "" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function is the implementation of Polar to cartesian Transformation." + NL + " */" + NL + "int32_t MOTORLIBS_Pol2Car(int16_t Angle,uint32_t Amplitude, int32_t *X)" + NL + "{" + NL + "  int32_t TempAngle;" + NL + "  int32_t TempX, TempY;" + NL + "  TempAngle =(int32_t)Angle; " + NL + "  /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->STATC =(uint32_t) MOTORLIBS_CLEAR_KEEPX + \\" + NL + "                    (uint32_t) MOTORLIBS_CLEAR_KEEPY + \\" + NL + "                    (uint32_t) MOTORLIBS_CLEAR_KEEPZ;" + NL + "" + NL + "  MotorMath->CON = (uint32_t) MOTORLIBS_CIRCULAR_MODE + \\" + NL + "                   (uint32_t) MOTORLIBS_ROTATION_MODE + \\" + NL + "                   (uint32_t) MOTORLIBS_CORDIC_AUTO_START + \\" + NL + "                   (uint32_t) MOTORLIBS_UNSIGNED_X_RESULT + \\" + NL + "                   (uint32_t) MOTORLIBS_MPS_DIVBY1;" + NL + "" + NL + "  /*Loading CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->CORDZ= TempAngle <<((uint32_t)MOTORLIBS_ANGLESCALE+MATH_CORDZ_DATA_Pos);" + NL + "" + NL + "  WR_REG(MotorMath->CORDY, MATH_CORDY_DATA_Msk, \\" + NL + "               MATH_CORDY_DATA_Pos, 0);" + NL + "  WR_REG(MotorMath->CORDX, MATH_CORDX_DATA_Msk, \\" + NL + "                       MATH_CORDX_DATA_Pos, Amplitude);" + NL + "" + NL + "  /*Checking for CORIDC Busy Bit*/" + NL + "  while((MotorMath->STATC &0x1)==1);" + NL + "  /* Update the x and y Values*/" + NL + "  TempX  =MotorMath->CORRX;" + NL + "  TempY = MotorMath->CORRY;" + NL + "" + NL + "  *X = (TempX >>(int32_t)MOTORLIBS_AMPSCALE);" + NL + "  return (TempY >>(int32_t)MOTORLIBS_AMPSCALE);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function is the implementation of park transform." + NL + " */" + NL + "int32_t MOTORLIBS_ParkTransform(int32_t Ialpha,int32_t Ibeta,int16_t Angle,int32_t *Iq)" + NL + "{" + NL + "  int32_t TempAngle;" + NL + "  int32_t Tempd, Tempq;" + NL + "  TempAngle =(int32_t)Angle; " + NL + "  /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->STATC =(uint32_t) MOTORLIBS_CLEAR_KEEPX + \\" + NL + "                      (uint32_t) MOTORLIBS_CLEAR_KEEPY + \\" + NL + "                  (uint32_t) MOTORLIBS_CLEAR_KEEPZ;" + NL + "" + NL + "  MotorMath->CON = (uint32_t) MOTORLIBS_CIRCULAR_MODE + \\" + NL + "                     (uint32_t) MOTORLIBS_ROTATION_MODE + \\" + NL + "                     (uint32_t) MOTORLIBS_CORDIC_AUTO_START + \\" + NL + "                     (uint32_t) MOTORLIBS_UNSIGNED_X_RESULT + \\" + NL + "                     (uint32_t) MOTORLIBS_MPS_DIVBY2;" + NL + "" + NL + "   /*Loading CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->CORDZ= TempAngle <<((uint32_t)MOTORLIBS_ANGLESCALE+MATH_CORDZ_DATA_Pos);" + NL + "" + NL + "  WR_REG(MotorMath->CORDY, MATH_CORDY_DATA_Msk, \\" + NL + "                 MATH_CORDY_DATA_Pos, Ialpha);" + NL + "  WR_REG(MotorMath->CORDX, MATH_CORDX_DATA_Msk, \\" + NL + "                         MATH_CORDX_DATA_Pos, Ibeta);" + NL + "" + NL + "  /*Checking for CORIDC Busy Bit*/" + NL + "  while((MotorMath->STATC &0x1)==1);" + NL + "  /* Update the Amplitude and Angle Values*/" + NL + "  Tempq  =MotorMath->CORRX;" + NL + "  Tempd = MotorMath->CORRY;" + NL + "" + NL + "  *Iq = (Tempq >>(int32_t)MOTORLIBS_AMPSCALE);" + NL + "  return (Tempd >>(int32_t)MOTORLIBS_AMPSCALE);" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function is the implementation of Inverse park transform." + NL + " */" + NL + "int32_t MOTORLIBS_IParkTransform(int32_t Vd,int32_t Vq,int16_t Angle,int32_t *Vbeta)" + NL + "{" + NL + "  int32_t TempAngle;" + NL + "  int32_t TempBeta, TempAlpha;" + NL + "  TempAngle =(int32_t)Angle; " + NL + "    /*Clearing previous values of CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->STATC =(uint32_t) MOTORLIBS_CLEAR_KEEPX + \\" + NL + "                      (uint32_t) MOTORLIBS_CLEAR_KEEPY + \\" + NL + "                  (uint32_t) MOTORLIBS_CLEAR_KEEPZ;" + NL + "" + NL + "  MotorMath->CON = (uint32_t) MOTORLIBS_CIRCULAR_MODE + \\" + NL + "                     (uint32_t) MOTORLIBS_ROTATION_MODE + \\" + NL + "                     (uint32_t) MOTORLIBS_CORDIC_AUTO_START + \\" + NL + "                     (uint32_t) MOTORLIBS_UNSIGNED_X_RESULT + \\" + NL + "                     (uint32_t) MOTORLIBS_MPS_DIVBY4;" + NL + "" + NL + "   /*Loading CORDX,CORDY and CORDZ Registers*/" + NL + "  MotorMath->CORDZ= TempAngle <<((uint32_t)MOTORLIBS_ANGLESCALE+MATH_CORDZ_DATA_Pos);" + NL + "" + NL + "  WR_REG(MotorMath->CORDY, MATH_CORDY_DATA_Msk, \\" + NL + "                 MATH_CORDY_DATA_Pos, Vq);" + NL + "  WR_REG(MotorMath->CORDX, MATH_CORDX_DATA_Msk, \\" + NL + "                         MATH_CORDX_DATA_Pos, Vd);" + NL + "" + NL + "  /*Checking for CORIDC Busy Bit*/" + NL + "  while((MotorMath->STATC &0x1)==1);" + NL + "  /* Update the Amplitude and Angle Values*/" + NL + "  TempAlpha  =(int32_t)MotorMath->CORRX;" + NL + "  TempBeta = (int32_t)MotorMath->CORRY;" + NL + "  *Vbeta = (TempBeta >>(int32_t)MOTORLIBS_AMPSCALE);" + NL + "  " + NL + "  return ((TempAlpha >>(int32_t)MOTORLIBS_AMPSCALE));" + NL + "    " + NL + "}" + NL;
  protected final String TEXT_8 = NL + NL + "uint32_t MOTORLIBS_Car2Pol(int32_t x,int32_t y, int16_t *Angle)" + NL + "{" + NL + "  uint8_t CordicCount;" + NL + "  int32_t dx,flag = 0, tempAngle = 0,CORDX =x,CORDY=y;" + NL + "  if(CORDX < 0)" + NL + "  {" + NL + "    CORDX = -CORDX;" + NL + "  flag = 1;" + NL + "  }" + NL + "  for (CordicCount = 0; CordicCount < CORDIC_ITERATIONS; CordicCount++)" + NL + "  {" + NL + "    dx =  CORDX >> CordicCount;" + NL + "  if( CORDY > 0 )" + NL + "  {" + NL + "    CORDX += CORDY >> CordicCount;" + NL + "    CORDY -= dx;" + NL + "      tempAngle -= e[CordicCount];" + NL + "    }" + NL + "  else" + NL + "  {" + NL + "    CORDX -= CORDY >> CordicCount;" + NL + "    CORDY += dx;" + NL + "    tempAngle += e[CordicCount];" + NL + "  }" + NL + "  }" + NL + "" + NL + "  *Angle = (int16_t)(((flag) ?  tempAngle + 0x80000000: -tempAngle)>>16);" + NL + "  return (CORDX>>MOTORLIBS_MPS_DIVBY1);" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of Polar to cartesian Transformation." + NL + " */" + NL + "int32_t MOTORLIBS_Pol2Car(int16_t Angle,uint32_t Amplitude, int32_t *x)" + NL + "{" + NL + "  uint8_t CordicCount, flag=0;" + NL + "  int32_t dx,CORDX =Amplitude,CORDY=0,tempAngle = Angle<<16;" + NL + "" + NL + "  if (MOTORLIBS_ABS(tempAngle) > 0x40000000U)" + NL + "  {" + NL + "    tempAngle = 0x80000000 - tempAngle;" + NL + "    CORDX = -CORDX;" + NL + "  flag = 1;" + NL + "  }" + NL + "" + NL + "  for (CordicCount = 0; CordicCount < CORDIC_ITERATIONS; CordicCount++)" + NL + "  {" + NL + "    dx = CORDX>>CordicCount;" + NL + "    if(tempAngle > 0)" + NL + "    {" + NL + "      CORDX -= CORDY>>CordicCount;" + NL + "      CORDY += dx;" + NL + "      tempAngle -= e[CordicCount];" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      CORDX += CORDY>>CordicCount;" + NL + "      CORDY -= dx;" + NL + "      tempAngle += e[CordicCount];" + NL + "    }" + NL + "  }" + NL + "  *x = CORDX>>MOTORLIBS_MPS_DIVBY1;" + NL + "  return(flag? -CORDY>>MOTORLIBS_MPS_DIVBY1: CORDY>>MOTORLIBS_MPS_DIVBY1);" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of park transform." + NL + " */" + NL + "int32_t MOTORLIBS_ParkTransform(int32_t Ialpha,int32_t Ibeta,int16_t Angle,int32_t *Iq)" + NL + "{" + NL + "  uint8_t CordicCount, flag=0;" + NL + "  int32_t dx,CORDX =Ibeta,CORDY=Ialpha,tempAngle = Angle<<16;;" + NL + "" + NL + "  if ( MOTORLIBS_ABS(tempAngle) > 0x40000000U)" + NL + "  {" + NL + "    tempAngle = 0x80000000 - tempAngle;" + NL + "    CORDX = -CORDX;" + NL + "    flag = 1;" + NL + "  }" + NL + "" + NL + "" + NL + "  for (CordicCount = 0; CordicCount < CORDIC_ITERATIONS; CordicCount++)" + NL + "  {" + NL + "    dx = CORDX>>CordicCount;" + NL + "" + NL + "    if(tempAngle > 0)" + NL + "    {" + NL + "      CORDX -= CORDY>>CordicCount;" + NL + "      CORDY += dx;" + NL + "      tempAngle -= e[CordicCount];" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      CORDX += CORDY>>CordicCount;" + NL + "      CORDY -= dx;" + NL + "      tempAngle += e[CordicCount];" + NL + "    }" + NL + "  }" + NL + "  *Iq = CORDX>>MOTORLIBS_MPS_DIVBY2;" + NL + "  return(flag? -CORDY>>MOTORLIBS_MPS_DIVBY2: CORDY>>MOTORLIBS_MPS_DIVBY2);" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of Inverse park transform." + NL + " * Valpha  = k/4*(Vd*cos(Anlge)- Vq*sin(Angle))" + NL + " * Vbeta   = k/4*(Vd*sin(Anlge)+Vq*cos(Angle))" + NL + " */" + NL + "int32_t MOTORLIBS_IParkTransform(int32_t Vd,int32_t Vq,int16_t Angle,int32_t *Vbeta)" + NL + "{" + NL + "  uint8_t CordicCount, flag=0;" + NL + "  int32_t dx,CORDX =Vd,CORDY=Vq,tempAngle = Angle<<16;;" + NL + "" + NL + "  if ( MOTORLIBS_ABS(tempAngle) > 0x40000000U)" + NL + "  {" + NL + "    tempAngle = 0x80000000 - tempAngle;" + NL + "    CORDX = -CORDX;" + NL + "    flag = 1;" + NL + "  }" + NL + "" + NL + "" + NL + "  for (CordicCount = 0; CordicCount < CORDIC_ITERATIONS; CordicCount++)" + NL + "  {" + NL + "    dx = CORDX>>CordicCount;" + NL + "" + NL + "    if(tempAngle > 0)" + NL + "    {" + NL + "      CORDX -= CORDY>>CordicCount;" + NL + "      CORDY += dx;" + NL + "      tempAngle -= e[CordicCount];" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      CORDX += CORDY>>CordicCount;" + NL + "      CORDY -= dx;" + NL + "      tempAngle += e[CordicCount];" + NL + "    }" + NL + "  }" + NL + "  *Vbeta =flag? -CORDY>>MOTORLIBS_MPS_DIVBY4: CORDY>>MOTORLIBS_MPS_DIVBY4;" + NL + "  return( CORDX>>MOTORLIBS_MPS_DIVBY4);" + NL + "}" + NL;
  protected final String TEXT_9 = NL + "/**" + NL + " * This function is the implementation of Clarke transform using 2 Phase current." + NL + " */" + NL + "" + NL + "int32_t MOTORLIBS_ClarkTransform(int32_t Phase_A, int32_t Phase_B, int32_t *Ialpha)" + NL + "{" + NL + "  *Ialpha  = (int32_t)(Phase_A >>MOTORLIBS_CLARKESCALE);" + NL + "  return  (int32_t)(((Phase_A + 2*Phase_B)*(MOTORLIBS_INVSQRT3))>>(15+MOTORLIBS_CLARKESCALE));" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of Clarke transform using 3 Phase current." + NL + " */" + NL + "int32_t MOTORLIBS_ClarkTransform2(int32_t Phase_A, int32_t Phase_B, int32_t Phase_C, int32_t *Ialpha )" + NL + "{" + NL + "  *Ialpha  = (int32_t)(Phase_A >>MOTORLIBS_CLARKESCALE);" + NL + "  return (int32_t)(((Phase_B-Phase_C)*(MOTORLIBS_INVSQRT3))>>(15+MOTORLIBS_CLARKESCALE));" + NL + "}" + NL + "" + NL + "/**" + NL + " * This function is the implementation of PI controller. " + NL + " */" + NL + "void MOTORLIBS_PIController" + NL + "(" + NL + "    MOTORLIBS_PIHandleType* HdlPtr," + NL + "    int32_t RefValue," + NL + "    int32_t ActValue" + NL + ")" + NL + "{" + NL + "  int32_t Output=0;" + NL + "  /* yn(k+1)= yn(k)   + ki * e(k) */" + NL + "  HdlPtr->Ibuf += (int32_t) ((int32_t)HdlPtr->Ki) * (RefValue-ActValue);" + NL + "" + NL + "  /* Checking the buffer limits in the range of Yimin to Yimax */" + NL + "  HdlPtr->Ibuf = MOTORLIBS_MIN_MAX_LIMIT(((int32_t)HdlPtr->Ibuf),((int32_t)HdlPtr->Yimax),((int32_t)HdlPtr->Yimin));" + NL + "" + NL + "  /* y(k+1) = yn(k+1) + kp * e(k) * 64 */" + NL + "  Output=  ((int32_t) ((int32_t)HdlPtr->Kp) * (RefValue-ActValue));" + NL + "" + NL + "  Output  =  (HdlPtr->Ibuf>>MOTORLIBS_PI_KISCALE) +(Output>>MOTORLIBS_PI_KPSCALE);" + NL + "  " + NL + "  /* Checking the buffer limits in the range of Ymin to Ymax */" + NL + "  HdlPtr->PiOutVal= MOTORLIBS_MIN_MAX_LIMIT(((int32_t)(Output)),((int32_t)HdlPtr->Ymax),((int32_t)HdlPtr->Ymin));" + NL + "" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of PT1 filter. " + NL + " */" + NL + "void MOTORLIBS_PT1Controller" + NL + "(" + NL + "   MOTORLIBS_PT1HandleType* HdlPtr," + NL + "   int32_t ActValue" + NL + ")" + NL + "{" + NL + "  int32_t TempBuff;" + NL + "  /* yn+1=yn + z1*(x - yn) */" + NL + "  TempBuff = HdlPtr->PT1buf + HdlPtr->Z1*(ActValue - (HdlPtr->PT1buf>>16));" + NL + "  /* Checking the buffer limits in the range of Ymin to Ymax */" + NL + "  HdlPtr->PT1buf = MOTORLIBS_MIN_MAX_LIMIT((TempBuff),(HdlPtr->Ymax),(HdlPtr->Ymin));" + NL + "  HdlPtr->PT1OutVal = (HdlPtr->PT1buf>>16);" + NL + "}" + NL + "/**" + NL + " * This function is the implementation of PT12 filter. " + NL + " */" + NL + "void MOTORLIBS_PT12Controller" + NL + "(" + NL + "   MOTORLIBS_PT1HandleType* HdlPtr," + NL + "   int32_t ActValue" + NL + ")" + NL + "{ " + NL + "  int32_t TempBuff;" + NL + "  /* yn+1=yn + z1*x - z2*yn; */" + NL + "  TempBuff = HdlPtr->PT1buf + ( (HdlPtr->Z1* ActValue) - (HdlPtr->Z2*(HdlPtr->PT1buf>>16)));" + NL + "   " + NL + "  /* Checking the buffer limits in the range of Ymin to Ymax */" + NL + "  HdlPtr->PT1buf = MOTORLIBS_MIN_MAX_LIMIT((TempBuff),(HdlPtr->Ymax),(HdlPtr->Ymin));" + NL + "" + NL + "  HdlPtr->PT1OutVal = (HdlPtr->PT1buf>>16);    " + NL + "} " + NL + "" + NL + "#endif " + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_10 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/motorlibs/"; 
     int Is44Device = -1; 
     int Is42Device = -1; 
     int Is4xDevice = -1; 
     int Is13Device = -1; 
     Is4xDevice = ((app.getSoftwareId().substring(0,1).compareTo("4")==0)?1:0); 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
     Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); 
     Is13Device = ((app.getSoftwareId().substring(0,2).compareTo("13")==0)?1:0); 
    stringBuffer.append(TEXT_2);
    if(Is13Device == 1){
    stringBuffer.append(TEXT_3);
    }
    stringBuffer.append(TEXT_4);
    if(Is4xDevice == 1){
    stringBuffer.append(TEXT_5);
    }
    stringBuffer.append(TEXT_6);
    if(Is13Device == 1){
    stringBuffer.append(TEXT_7);
    } else if (Is4xDevice == 1) {
    stringBuffer.append(TEXT_8);
    } 
    stringBuffer.append(TEXT_9);
    stringBuffer.append(TEXT_10);
    return stringBuffer.toString();
  }
}
